---
title: "modelo econometrico version 4"
author: "Ana Munoz"
output: pdf_document
---

```{r setup, include=FALSE, warning=FALSE}
# LIBRERIA USADAS
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(corrplot)
library(psych)
library(ggplot2)
library(fitdistrplus)
library(plm)
library(lmtest)
library(car)
library(lubridate)

library(MASS)

```

# Pre procesamiento de datos
## 1. Lectura de datos y formato panel

```{r}
df <- read.csv('df_00_21_noclean.csv') %>%
  dplyr::select(year, country, total_earnings, # orden de datos panel
         total_players,
         -iso, -code, #no aplica el modelo
         continent,
         subregion,
         pbicap, 
         gdp_gr,
         -CPI, # corrupcion
         internet, 
         -elect_acc,
         desempleo,
         pea, # tech access
         -net_mig,
         life_exp, # edades
         poblacion,# people
         inflacion
        ) %>%
  arrange(country, decreasing = FALSE)

head(df, 3)
```

## 2.  Valores faltantes
* Numero de Valores faltantes por variable
```{r}
sapply(df, function(x) sum(is.na(x)))
```
* corriegiendo los NAs
```{r}
# Pbi faltantes 
# 
df <- df %>%
  # filter(year < as.Date("2022-01-01"))%>%
  filter(subregion=="Southern Europe")
  # filter(continent=="Europe")

## "Cuba"  "Lebanon"  "Syrian Arab Republic"  "Venezuela"  
# pbicap_faltantes <- unique(df[is.na(df$pbicap), ]$country)
# desemp_faltantes <- unique(df[is.na(df$desempleo), ]$country)
internet_faltantes <- unique(df[is.na(df$internet), ]$country)
# elect_acc_faltantes <- unique(df[is.na(df$elect_acc), ]$country)
# df <- df[!df$country %in% pbicap_faltantes, ]
# df <- df[!df$country %in% desemp_faltantes, ]
df <- df[!df$country %in% internet_faltantes, ]
# df <- df[!df$country %in% elect_acc_faltantes, ]

###########

### Jugadores por poblacion por millon
df$players_ppl <- (df$total_players/df$poblacion)*1000000

# verificamos NAs, ahora no tengo NAS
sapply(df, function(x) sum(is.na(x)))
```
```{r}
summary(df)
```


## 3.  Normalizacion con logaritmo

* valores con varianzas muy grandes
* aplico normalizacion logaritmica en algunas variables

```{r}
df_standar <- df %>%
  mutate(across(c("total_earnings", "pbicap", "poblacion", "pea", "total_players"), ~log(.)))%>%
  mutate(year = year(df$year))
  # # mutate(across(colnames(df)[3:13], ~log(.)))%>%
  # # mutate(across(c("total_earnings", "pbicap", "poblacion", "pea", "total_players"), ~sqrt(.))) %>%
  # # mutate(across(c("total_earnings"), ~log(.))) %>%
  
```

```{r}

# df_standar <- df %>%
#   mutate(across(c(total_earnings, pbicap, poblacion, pea, total_players), ~ . + abs(min(., na.rm = TRUE)) * (. <= 0) + 1)
#          )%>%
#   mutate(year = year(df$year))
# 
# df_temp <- df_standar
# 
# bc <- boxcox(lm(pea ~ 1, data=df_temp))
# lambda_optimo <- bc$x[which.max(bc$y)]
# lambda_optimo
# # 0.02020202
# #0.1414141
# # -0.06060606
# #] -0.06060606
# #-0.06060606


# df_temp$total_earnings <- (df_temp$total_earnings^0.02020202 - 1) / 0.02020202
# df_temp$pbicap <- (df_temp$pbicap^0.1414141 - 1) / 0.1414141
# df_temp$poblacion <- (df_temp$poblacion^-0.06060606 - 1) / -0.06060606
# df_temp$pea <- (df_temp$pea^-0.06060606 - 1) / -0.06060606
# df_temp$total_players <- (df_temp$total_players^-0.06060606 - 1) / -0.06060606
# 
# 
# df_standar <- df_temp
```


```{r}
# df_standar <- df_temp
# 
# df_standar <- df_standar %>%
#   mutate(across(c("pbicap", "poblacion", "pea", "total_players"), ~log(.)))

```


```{r}
# df_temp$total_earnings
# graficar
# ggplot(df_temp, aes(x = total_earnings)) +
#   geom_histogram() +
#   labs(title = "Histograma de Total Earnings",
#        x = "Total Earnings",
#        y = "Frecuencia") +
#   theme_minimal()
```



## 0. Preparando los datos
* Tenemos datos panel con la siguente forma 90 paises 5 anios y estas columnas
* Nuestro panel es balanceado y corto

```{r}
df_standar %>% 
  group_by(country) %>% 
  summarise(count = n()) %>%
  filter(count<20)
```

```{r}
dim(table(df_standar$country,df_standar$year))

colnames(df_standar)
```

* definimos las variables para el modelo
```{r, warning=FALSE}
attach(df_standar)
Y <- cbind(total_earnings)
X <- cbind(
          pbicap,
           #gdp_gr,
           internet,
           #life_exp,
           #CPI,
           #elect_acc,
           pea,
           desempleo,
           poblacion,
           # players_ppl,
           inflacion,
           total_players
           # net_mig
           )

df_panel <- pdata.frame(df_standar,
                        index=c('country','year'))

head(df_panel,3)
```

## 1. Efectos Fijos
```{r}
fijos <- plm(Y ~ X, data=df_panel, index=c('country','year'), model= "within")
summary(fijos)
```

## 2. Efectos aleatorios
```{r}
random <- plm(Y ~ X, data=df_panel, index=c('country','year'), model= "random")
summary(random)
```
## 3. MCO

```{r}
mco_pool = plm(Y ~ X, data=df_panel,index=c("state", "year"), model="pooling")
mco = lm(Y ~ X, data=df_panel)
# summary(mco)
```

# Test para escoger el mejor modelo

## 1. F test
*  H0: modelo (MCO) vs H1: efectos fijos
* p<0.05 entonces rechazo Ho, el mejor modelo seria efectos fijos
```{r}
pFtest(fijos, mco) 
```

## 2. Breusch-Pagan
* H0: modelo agrupado (MCO) vs H1: efectos aleatorios
* p<0.05 entonces rechazo la Ho, por ahora el mejor modelo seria aleatorios
```{r}
plmtest(mco_pool, type=c("bp"))
```

## 3. Hausman test 
* H0: efectos aleatorios vs H1: efectos fijos
* p<0.05 entonces rechazo Ho y decido que efectos fijos es mejor
```{r}
phtest(fijos, random)
```



# Regresiones
## Regresieon con efectos fijos

### by Country Spain

```{r}
df_panel$country <- relevel(df_panel$country, ref = "China")
regresion_country_sp = lm(Y ~ X + factor(country), data = df_panel)

# summary(regresion_country)


p_values <- summary(regresion_country_sp)$coefficients[,4]
coeficiente <- summary(regresion_country_sp)$coefficients[,1]

no_significativo <- names(p_values)[which(p_values > 0.05)]

significativo_positivos <- names(p_values)[which(p_values < 0.05 & coeficiente>0)]

significativo_negativos <- names(p_values)[which(p_values < 0.05 & coeficiente<0)]
```


```{r}
# summary(regresion_country_sp)
#H0 : la distribución es normal
shapiro.test(residuals(regresion_country_sp))

```
```{r}
library(lmtest)
bptest(regresion_country_sp)

```
```{r}
dwtest(regresion_country_sp)

```
```{r}
library(car)
vif(regresion_country_sp)
```




### Analizando significancias
```{r}
no_significativo
```

```{r}
significativo_positivos
```

```{r}
significativo_negativos
```

### By year
* El año en sí mismo no parece tener un efecto significativo en Y después de ajustar por X
```{r}
regresion_years = lm(Y~X+factor(year))
summary(regresion_years)
```


# OTRAS IDEAS

### Top 3 country
```{r}
 df_panel %>%
  group_by(country) %>%
  top_n(3, total_earnings) %>%
  arrange(desc(total_earnings))

```

### Crecimiento de ganancia
```{r}
df_panel %>%
  group_by(country) %>%
  mutate(year = as.integer(year)) %>%
  summarise(CAGR = ifelse((last(year) - first(year)) != 0, 
                          (last(total_earnings) / first(total_earnings))^(1/(last(year)-first(year))) - 1, 0)) %>%
  arrange(desc(CAGR))
```

### Top 3 paises ganancias en el tiempo

```{r}
ggplot(data = df_panel, aes(x = poblacion, y = total_earnings)) +
  geom_point() + # Añadimos los puntos del scatter plot
   #geom_smooth() #method = "lm", se = TRUE, color = "blue") +
  labs(x = "Población", y = "Total de Ganancias", title = "Relación entre Población y Total de Ganancias") +
  theme_minimal() # Tema minimalista para el gráfico
```



```{r}
ggplot(df_panel %>%
  group_by(year) %>%
  filter(country %in% c('China', 'United States', 'Korea, Republic of')), 
  aes(x = year, y = total_earnings, group = country, color=country)) +
  geom_line() +
  labs(x = "Year", y = "total_earnings") +
  ggtitle("Paises con mayor ingresos") 
```

# Tops 3 paises crecimiento en el tiempo
```{r}
ggplot(df_panel %>%
  group_by(year) %>%
  filter(country %in% c("Luxembourg", "Paraguay", "Costa Rica")),
  aes(x = year, y = total_earnings, group = country, color=country)) +
  geom_line() +
  labs(x = "Year", y = "Life total_earnings") +
  ggtitle("Paises con mayor CAGR") 
```

